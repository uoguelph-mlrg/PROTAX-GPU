# Test full inference on a small 37k real dataset
# targets generated by c protax

import pandas as pd
import jax.numpy as jnp
from protax import protax_utils, model
import numpy as np

from pathlib import Path

cwd = Path.cwd()
DEBUG_Z_F= cwd / "testfiles" / "small_z.csv"
DEBUG_SEQ_F= cwd / "testfiles" / "debug.aln"
DEBUG_X_F = cwd / "testfiles" / "small_x.csv"
PARAMS37K = cwd.parent / "models" / "params" / "model.npz"
TAX37K = cwd.parent / "models" / "ref_db" / "taxonomy37k.npz"

# TODO: remove pandas dependency
TARG_Z = pd.read_csv(DEBUG_Z_F)
TARG_X = pd.read_csv(DEBUG_X_F).to_numpy()

# loading test model and query into mem
tree, params, N, segnum = protax_utils.read_model_jax(PARAMS37K, TAX37K)
f = open(DEBUG_SEQ_F)
name = f.readline().strip('\n').split('\t')[0]
seqs = f.readline().strip('\n')
q, ok = protax_utils.read_query(seqs)

def test_X():
    """
    Test design matrix correctness within reasonable threshold
    """
    log = []

    X = np.array(model.get_X(q, ok, tree, N, params.sc_mean, params.sc_var))
    prop = np.sum(X[:, :2] == TARG_X[:, :2])/(2*N)
    log.append(f"binary variables correct: {prop}")
    assert prop > 0.95, f"proportion of matching design matrix rows lower than 95% - ({prop})"
    
    accept = [0.95, 0.95, 0.95, 0.90]
    for a, t in enumerate([0.001/(10**i) for i in range(0, 4)]):
        diff = jnp.abs(X[:, 2:] - TARG_X[:, 2:])
        log.append(f"distances correct ±{t}: {np.sum(diff < t)/(2*N)}")
        assert np.sum(diff < t)/(2*N) > accept[a], f"proportion of distances within {t} lower than {a}: {np.sum(diff < t)/(2*N)}"
    
    return log


def test_z_and_bprob():
    """
    Test the correctness on the 30k small set over entire design matrix
    """
    log = []

    # testing design matrix
    X = np.array(model.get_X(q, ok, tree, N, params.sc_mean, params.sc_var))
    bprobs = jnp.prod(model.fill_bprob(X, params.beta, tree, segnum), axis=1)
    log_bprobs = jnp.sum(model.fill_log_bprob(X, params.beta, tree, segnum), axis=1)
    
    prop = jnp.sum(jnp.abs(bprobs - jnp.exp(log_bprobs)) < 0.00001)/N
    log.append(f"log probs correct ±1e-5: {prop}")
    assert prop > 0.95, f"propertion of matching log probs within ±1e-5 lower than 95%: {prop}"


    return log


if __name__ == "__main__":
    test_X()
    test_z_and_bprob()
    print("passed all")
